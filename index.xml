<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zwPapEr on zwPapEr</title>
    <link>https://page.codespaper.com/</link>
    <description>Recent content in zwPapEr on zwPapEr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 10 Mar 2019 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>为什么我觉得 Golang 更好</title>
      <link>https://page.codespaper.com/2019/why-golang/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2019/why-golang/</guid>
      <description>

&lt;h2 id=&#34;less-is-exponentially-more-读后感&#34;&gt;Less is exponentially more 读后感&lt;/h2&gt;

&lt;p&gt;最近看到 Rob Pike 在 2012 年写的一篇文章，&lt;a href=&#34;https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Less is exponentially more&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你不知道 Rob Pike 是谁：&lt;a href=&#34;https://zh.wikipedia.org/wiki/%25E7%25BE%2585%25E5%258B%2583%25C2%25B7%25E6%25B4%25BE%25E5%2585%258B&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rob Pike&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或者用一句话介绍，Golang 作者之一&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;结合之前看到对于 Golang 编程思想的讨论，对这篇文章真是相见恨晚&lt;/p&gt;

&lt;h2 id=&#34;从-c-到-golang&#34;&gt;从 C++ 到 Golang&lt;/h2&gt;

&lt;p&gt;Golang 的前身是 Rob Pike 在 1980+ 年在贝尔实验室写的一门编程语言：&lt;a href=&#34;https://swtch.com/~rsc/thread/newsqueak.pdf&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Newsqueak&lt;/a&gt;，
在 2007 年的时候，C++标准委员会正在紧锣密鼓地准备 C++0x (现在的 C++11)，
作为一名在 Google 的 C++ 工程师 Rob Pike 自然也十分关注，可是也在这时候，
Rob 觉得不应该把这么多的特性都放到一门语言里，同时也觉得在 Newsqueak 里有一些特性，
如果能用在开发里，会对服务器端的很多开发都会有帮助。&lt;/p&gt;

&lt;p&gt;可是 C++ 庞大复杂的体系，要加一些比较不一样的特性已经不是一件易事，而且可能也不值得，
所以在 C++ 项目编译的时间里（编译一次要 45 分钟，还是在编译集群上！）Rob 就拉上了
&lt;a href=&#34;https://en.wikipedia.org/wiki/Ken%5FThompson&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Ken Thompson&lt;/a&gt; 和 Robert Griesemer 决定要做点事情，Golang 从此开始登上历史的舞台。&lt;/p&gt;

&lt;p&gt;要知道 Ken, Rob, 都是贝尔实验室的大佬，一直在 Google 做 C++, 决心要针对 C++ 做一个优化，
这就是突破性的了，更别说 Ken 是 Unix，Plan 9，C 语言作为作者之一。&lt;/p&gt;

&lt;h2 id=&#34;大道至简&#34;&gt;大道至简&lt;/h2&gt;

&lt;p&gt;在文章中，就如文章标题，Rob 希望重新造轮子的原因主要就是觉得 C++ 太复杂了，觉得大道应该至简，
所以才考虑重新从头设计一门语言。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章里多次提到了在 C++ 编译的时候，Rob 去找同事们聊天，这个编译时间，
对 Rob 来说，应该还是感觉挺难受的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本来 Robert 希望 Go 从 C 语言出发，但是最后还是决定，从零出发，至简就该如此。所以网上常说 Golang
是 Better C，其实 Golang 是 Better language。&lt;/p&gt;

&lt;p&gt;文章中提到了很多的简化，只要写代码过程中，可能需要考虑，而又没必要的东西，Golang 都直接不出现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有头文件&lt;/li&gt;
&lt;li&gt;常量只能是数字&lt;/li&gt;
&lt;li&gt;没有子类型继承&lt;/li&gt;
&lt;li&gt;文件被编译到一个包里&lt;/li&gt;
&lt;li&gt;没有指针运算&lt;/li&gt;
&lt;li&gt;内存一直以零值初始化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等。&lt;/p&gt;

&lt;p&gt;甚至，连泛型都没有，而且 Golang 也借鉴了函数式编程的函数作为 &lt;code&gt;first class object&lt;/code&gt; ，
但是其它一些函数式编程的优点就什么也都没有了，就像： &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt; 等，&lt;/p&gt;

&lt;p&gt;因为 Rob 说，用 &lt;code&gt;for&lt;/code&gt; 吧&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/robpike/filter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/robpike/filter&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从语言层面，Golang 就对代码规范进行了限制，还提供了 fmt 格式化工具，doc 文档体系，
这都像是在说，这些不关紧要的东西，就都不要去考虑了。&lt;/p&gt;

&lt;p&gt;并发，也是一样的，从语言级别的支持，一个 &lt;code&gt;go&lt;/code&gt; 关键字，加上 &lt;code&gt;channel&lt;/code&gt; 的 CSP 并发模型，
可以说是很大程度地简化了开发高并发软件的复杂度。&lt;/p&gt;

&lt;h2 id=&#34;真正的-oop&#34;&gt;真正的 OOP&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;If C++ and Java are about type hierarchies and the taxonomy of types, Go is about composition.&lt;/p&gt;

&lt;p&gt;Go takes that idea and pushes it very far. It is a language of composition and coupling.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之前看到一个讨论，就在说 Golang 的编程思想，提到为什么 Golang 不用传统的 OOP 思想，
而是用了一套 &lt;code&gt;组合&lt;/code&gt; 代替，原因也在这，Rob 认为 Java 和 C++ 推崇的 OOP 思想更多的是历史包袱，
程序员们更应该关注的是接口。&lt;/p&gt;

&lt;p&gt;目前的 OOP 思想更多的都是 Java 和 C++ 的流行而发展出来的，与最初的 &lt;code&gt;对象范式&lt;/code&gt; 已经走上不同的道路了。
Golang 也许是第一个明确使用了最初 &lt;code&gt;对象范式&lt;/code&gt; 设计的语言，这个可能还需要用一篇文章来研究。&lt;/p&gt;

&lt;h2 id=&#34;高层抽象&#34;&gt;高层抽象&lt;/h2&gt;

&lt;p&gt;最近也在看一些函数式编程的文章，有一个观点我还是挺认可的：&lt;/p&gt;

&lt;p&gt;函数式编程把一些无关紧要的问题封装在了语言级别，写程序时，可以不需要考虑，如 &lt;code&gt;内存管理&lt;/code&gt; ， &lt;code&gt;for 循环&lt;/code&gt; 等。
以前函数式编程不流行，更多的是因为当时的算力或者编译程序不足以让函数式语言的体验与过程式语言匹敌，
但是现在时机已经来了，函数式编程马上要再次走上舞台了。&lt;/p&gt;

&lt;p&gt;一个例子是 &lt;code&gt;内存管理&lt;/code&gt; ，虽然说这是很多高级语言都有的特性，可是这不也是一个证明，语言级别能解决好的事情，
就让语言去解决吧。&lt;/p&gt;

&lt;p&gt;另一个例子是 Clojure 一次对 Map 和 vector 扩展，内部进行了并行优化，开发者不需要改变就得到了性能提升。&lt;/p&gt;

&lt;p&gt;Golang 对并发的封装，也是一个高层抽象的表现。&lt;/p&gt;

&lt;p&gt;这个也可能需要一篇文章来研究。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 GPG 在 Emacs 中加密 Org Mode 笔记文件</title>
      <link>https://page.codespaper.com/2019/gpg-encrypt-org/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2019/gpg-encrypt-org/</guid>
      <description>

&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;Org Mode 作为主要 GTD 和笔记软件，需要使用网盘来同步信息，虽然 Dropbox 名声十分良好，
但是有一些敏感信息，还是认为谁都不值得信任。&lt;/p&gt;

&lt;p&gt;所以需要使用 GPG 加密后再传到 Dropbox，而 Emacs 中， &lt;code&gt;EasyPG Assistant&lt;/code&gt; 可以很方便地加解密。&lt;/p&gt;

&lt;h2 id=&#34;gpg&#34;&gt;GPG&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/GnuPG&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zh.wikipedia.org/wiki/GnuPG&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GNU Privacy Guard（GnuPG或GPG）是一种加密软件，它是PGP加密软件的满足GPL的替代物。GnuPG依照由IETF订定的OpenPGP技术标准设计。
GnuPG用于加密、数字签名及产生非对称钥匙对的软件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果不了解 GPG，推荐看一下阮一峰老师的文章，快速入门
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/07/gpg.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.ruanyifeng.com/blog/2013/07/gpg.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单地说就是可以通过 GPG 使用两种方式加密文件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对称加密，只使用密码对文件进行加密&lt;/li&gt;
&lt;li&gt;非对称加密，使用 GPG 密钥对文件进行加密，只有使用私钥能进行解密，而且需要私钥密码才能使用私钥&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;h3 id=&#34;macos&#34;&gt;macOS&lt;/h3&gt;

&lt;p&gt;通过 brew 安装 gpg&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install gpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;emacs&#34;&gt;Emacs&lt;/h3&gt;

&lt;p&gt;通过 &lt;code&gt;use-package&lt;/code&gt; 配置 Emacs&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果没用过 &lt;code&gt;use-package&lt;/code&gt; 可以看一下：
&lt;a href=&#34;https://github.com/jwiegley/use-package&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/jwiegley/use-package&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;macOS 上的图形界面 Emacs 弹出密码窗口有问题，可以通过以下配置解决&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(setq epa-pinentry-mode &#39;loopback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，配置文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package epa-file
  :ensure nil
  :config
  (epa-file-enable)
  (setq epa-pinentry-mode &#39;loopback))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h3 id=&#34;对称加密&#34;&gt;对称加密&lt;/h3&gt;

&lt;p&gt;默认情况下，Emacs会使用对称加密的方法进行文件加密，实际就是用一个密码，使用 AES 对文件进行加密&lt;/p&gt;

&lt;p&gt;每次打开文件时，都要输入密码，保存时，甚至要输入两次，因为被当成新加密了。&lt;/p&gt;

&lt;p&gt;可以把密码缓存起来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(setq epa-file-cache-passphrase-for-symmetric-encryption t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再打开和保存这个文件时，就不用输入密码，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个缓存是在 &lt;code&gt;gpg agent&lt;/code&gt; 进程里的，如果能确保电脑没别人会用，倒还好，
否则别人也是可能通过 &lt;code&gt;gpg agent&lt;/code&gt; 的缓存读到解密内容的！
或者说使用完，关了 Emacs 之后，其它人再重新打开，尝试读取，也是能载入缓存的！&lt;/p&gt;

&lt;p&gt;可以通过加一个 Hook，在关 Emacs 的时候，把 &lt;code&gt;gpg agent&lt;/code&gt; 也杀了，相对能安全点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(add-hook &#39;kill-emacs-hook (defun personal--kill-gpg-agent ()
                             (shell-command &amp;quot;pkill gpg-agent&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里我们用 defun 而不是 lambda，有兴趣可以看一下这篇文章：
&lt;a href=&#34;http://ergoemacs.org/emacs/emacs%5Favoid%5Flambda%5Fin%5Fhook.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://ergoemacs.org/emacs/emacs%5Favoid%5Flambda%5Fin%5Fhook.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;非对称加密&#34;&gt;非对称加密&lt;/h3&gt;

&lt;p&gt;使用 gpg key 对文件进行加密，这个目前应该是无懈可击的加密方式了&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;Org Mode&lt;/code&gt; 里使用非对称加密需要在文件开头加上：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-org&#34;&gt;# -*- mode:org; epa-file-encrypt-to: (&amp;quot;address@email.com&amp;quot;) -*-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在保存的时候，Emacs 会提示让选择一个 GPG Key 进行加密，
加密以后，再打开这个文件，需要提供 GPG Key 私钥密码进行解密，然后再保存就不需要输入密码了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我在用的时候有个问题，就是第一次新建文件加密保存后，每次都需要选择 Key 进行加密，
把 Buffer Kill 了之后，再打开文件使用就没有问题了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;gpg-相关&#34;&gt;GPG 相关&lt;/h3&gt;

&lt;h4 id=&#34;导出-key&#34;&gt;导出 Key&lt;/h4&gt;

&lt;p&gt;用了 GPG 加密，那私钥就非常的重要了，所以最好把私钥导出一份：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 找到自己的 Key ID，一长串字符
gpg --list-keys
# 导出，armor 表示使用可打印字符
gpg --export-secret-keys --armor AAAABBBBBBBBBCCCCCCC0000000000 &amp;gt;&amp;gt; /tmp/private.key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最重要的就是把导出文件保存好了，推荐离线保存！&lt;/p&gt;

&lt;p&gt;这个文件比较大，内容比较多。
可以把文件分割成几个小份，然后导出生成二维码，打印到纸上，离线保存。&lt;/p&gt;

&lt;h4 id=&#34;导入-key&#34;&gt;导入 Key&lt;/h4&gt;

&lt;p&gt;有导出，自然也有导入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gpg --import private.key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入之后 Key 没被信任，需要修改一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gpg --edit-key AAAABBBBBBBBBCCCCCCC0000000000
# 看到提示符后输入 trust
# 再选择信任等级，我自己的 Key，我选 5
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sessions control for hammerspoon</title>
      <link>https://page.codespaper.com/2015/sessions-control-hammerspoon-doc/</link>
      <pubDate>Sat, 11 Jul 2015 23:48:27 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2015/sessions-control-hammerspoon-doc/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Sessions control 是一套基于 hammerspoon(Mac) 的脚本程序。可以通过快捷键把 Mac 中的各个窗口归类，并快速的在各个分类中切换，包括全屏的窗口也会自己切换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意：本程序还处于开发状态，不会关闭或丢失窗口，但并不对稳定性提供保证，请勿用于正式工作中！&lt;/p&gt;

&lt;h1 id=&#34;hammerspoon&#34;&gt;Hammerspoon&lt;/h1&gt;

&lt;h1 id=&#34;sessions-control&#34;&gt;sessions control&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Sessions control 主要有以下三个功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;显示当前场景(sessions)&lt;/li&gt;
&lt;li&gt;为当前场景增删窗口(windows)&lt;/li&gt;
&lt;li&gt;在不同场景中切换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前实现主要通过把窗口最小化完成场景切换，后期版本会考虑把窗口隐藏，不占用任务栏空间。&lt;/p&gt;

&lt;p&gt;目前主要优势在于同时可以处理&lt;strong&gt;全屏窗口&lt;/strong&gt;，当切换场景时，全屏的窗口也会同时最小化，前台场景也会恢复应有的全屏状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;由于切换动画为系统动画，所以无法简单地关闭动画，在切换场景的时候会有部分动画。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各个场景都会定时保存到磁盘中，以保证各个场景不会因为 hammerspoon 或电脑的开关而丢失。&lt;/p&gt;

&lt;p&gt;对各个功能的快捷键提供定制，在脚本中可以很简单地修改快捷键。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;从 GitHub 中下载压缩包，或 clone 仓库到本地&lt;/li&gt;
&lt;li&gt;把 &lt;code&gt;sessions-control-hammerspoon&lt;/code&gt; 文件夹复制到 &lt;code&gt;~/.hammerspoon/&lt;/code&gt; 文件夹下&lt;/li&gt;
&lt;li&gt;更新 &lt;code&gt;~/.hammerspoon/&lt;/code&gt; 目录下 &lt;code&gt;init.lua&lt;/code&gt;，加入 sessions control 功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下载地址：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GitHub 地址：()[]&lt;/li&gt;
&lt;li&gt;GiuHub 压缩包地址：()[]&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;code&gt;.hammerspoon&lt;/code&gt; 是隐藏文件夹，如果找不到相应位置，可以运行下载的程序中的 &lt;code&gt;setup&lt;/code&gt; 程序，会自动复制相应文件到目标位置，并自动更新 &lt;code&gt;init.lua&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注：&lt;code&gt;init.lua&lt;/code&gt; 是 &lt;code&gt;hammerspoon&lt;/code&gt; 本身自带的初始化文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;功能说明&#34;&gt;功能说明&lt;/h2&gt;

&lt;p&gt;在本说明中使用默认的快捷键进行说明，操作主要是先按住功能键，然后点击相应快捷键，默认键位如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;功能键：
ctrl + alt + cmd&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示当前场景：P&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;前一场景：[&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下一场景：]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;加入当前场景：L&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从当前场景删除：；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字键快速切换：1 ~ 场景数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code&gt;数字键快速切换&lt;/code&gt; 会按照场景数自动生成，通过按住功能键，加上相应的数字可以快速在场景间切换。&lt;/p&gt;

&lt;p&gt;默认键位都位于键盘右侧，通过功能分区。&lt;/p&gt;

&lt;h3 id=&#34;显示当前场景&#34;&gt;显示当前场景&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;P&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过系统通知展示当前各个场景，并自动编号，便于后面的快速切换。&lt;/p&gt;

&lt;p&gt;当然，同时进行太多任务会很乱，所以不应该同时有太多场景，同时，系统通知中不可以放入过长的内容，所以刚刚好 (;¬_¬)&lt;/p&gt;

&lt;h3 id=&#34;前后场景&#34;&gt;前后场景&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;前一场景：按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;[&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下一场景：按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;这两个功能主要用于切换上一个或下一个场景，完成按键后，会自动记录当前窗口的全屏状态，并把当前场景的窗口最小后，然后切换到新场景，恢复新场景中的窗口状态。&lt;/p&gt;

&lt;h3 id=&#34;窗口操作&#34;&gt;窗口操作&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;加入：按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;L&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除：按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;这两个功能主要用于对当前窗口的操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;把正在使用的窗口加入到当前场景中&lt;/li&gt;
&lt;li&gt;从当前场景中删除正在使用的窗口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;增删窗口之后会弹出通知提示完成操作，并显示当前场景中共有几个窗口&lt;/p&gt;

&lt;h3 id=&#34;快速切换&#34;&gt;快速切换&lt;/h3&gt;

&lt;p&gt;在查看场景时，每个场景名之前会有一个序号，该序号可用于快速切换，主要用于跨越多个场景的切换时，避免多个最大化，最小化动画。&lt;/p&gt;

&lt;p&gt;使用方法就是按住功能键后，再按相应的序号键（注：未测试小键盘区）&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;程序实现&#34;&gt;程序实现&lt;/h1&gt;

&lt;p&gt;Sessions control 是基于 Hammerspoon 的脚本程序，使用 lua 编写，主要是两个文件实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sessions_control.lua&lt;/li&gt;
&lt;li&gt;sessions_head.lua&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了方便管理，把这两个文件放到了 &lt;code&gt;sessions-control-hammerspoon&lt;/code&gt; 文件夹中。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>