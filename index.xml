<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zwPapEr on zwPapEr</title>
    <link>https://page.codespaper.com/</link>
    <description>Recent content in zwPapEr on zwPapEr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 10 Aug 2019 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>开始用 Beancount 实践复式记账（一）：初始化</title>
      <link>https://page.codespaper.com/2019/beancount/</link>
      <pubDate>Sat, 10 Aug 2019 00:00:00 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2019/beancount/</guid>
      <description>

&lt;h2 id=&#34;复式记账-beancount&#34;&gt;复式记账 Beancount&lt;/h2&gt;

&lt;p&gt;第一次了解到复式记账是 Emacs 的 &lt;code&gt;Ledger mode&lt;/code&gt; ，但是还挺复杂的，就放弃了。后来 Byvoid 的&lt;a href=&#34;https://www.byvoid.com/zht/blog/beancount-bookkeeping-1&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Beancount 复式记账（一）：为什么&lt;/a&gt;里提到了 &lt;code&gt;Beancount&lt;/code&gt; ，感觉比较值得一试。&lt;/p&gt;

&lt;p&gt;目前 beancount 的中文文章还不算多，主要看了这两篇：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wzyboy.im/post/1063.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://wzyboy.im/post/1063.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yuchi.me/post/beancount-intro/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://yuchi.me/post/beancount-intro/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;p&gt;网上有很多安装教程，就不复述，主要就是安装 beancount 和 fava&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pip install beancount fava
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;archlinux&#34;&gt;ArchLinux&lt;/h3&gt;

&lt;p&gt;因为使用了 &lt;code&gt;ArchLinux&lt;/code&gt; ，在用 beancount 命令的时候会报&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;UserWarning: Fast C decimal implementation appears to be missing; Consider installing cdecimal
  warnings.warn(&amp;quot;Fast C decimal implementation appears to be missing; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个其实是因为在 ArchLinux 上少了 &lt;code&gt;mpdecimal&lt;/code&gt; 这个库，所以要安装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pacman -S mpdecimal
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;emacs&#34;&gt;Emacs&lt;/h3&gt;

&lt;p&gt;Beancount 作者也是 Emacs 用户，所以在项目里有一个 &lt;code&gt;beancount.el&lt;/code&gt; ，
&lt;a href=&#34;https://github.com/beancount/beancount/tree/master/editors/emacs&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/beancount/beancount/tree/master/editors/emacs&lt;/a&gt;
我们下载并放到 &lt;code&gt;load-path&lt;/code&gt; ，然后用 &lt;code&gt;use-package&lt;/code&gt; 配置一下即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package beancount
  :load-path &amp;quot;~/.emacs.d/plugin&amp;quot;
  :ensure nil
  :mode
  (&amp;quot;\\.bean$&amp;quot; . beancount-mode))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Emacs 里 Beancount mode 主要是语法高亮和加入了 Beancount 命令的调用，像：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;beancount-check&lt;/li&gt;
&lt;li&gt;beancount-insert-account&lt;/li&gt;
&lt;li&gt;beancount-insert-price&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些命令基本看字面意思也都能看出来。
&lt;code&gt;beancount-check&lt;/code&gt; ，用于检查当前文件有没有语法错误，这个目前是个人觉得最有用的&lt;/p&gt;

&lt;p&gt;后续可能我会更新我的配置，可以参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zwpaper/paper-emacs/blob/master/config/init-beancount.el&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/zwpaper/paper-emacs/blob/master/config/init-beancount.el&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;开始使用&#34;&gt;开始使用&lt;/h2&gt;

&lt;h3 id=&#34;初始化账户&#34;&gt;初始化账户&lt;/h3&gt;

&lt;p&gt;按照上文提到的两篇文章，我们已经可以初步建立我们的账户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;option &amp;quot;title&amp;quot; &amp;quot;Personal Ledger&amp;quot;
option &amp;quot;operating_currency&amp;quot; &amp;quot;CNY&amp;quot;
option &amp;quot;operating_currency&amp;quot; &amp;quot;USD&amp;quot;

1990-05-28 open Equity:Opening-Balances

1990-05-28 open Assets:Bank:CMB:xxxx:Deposit CNY
1990-05-28 open Assets:Bank:CMB:xxxx:ZZY CNY
20xx-xx-xx open Assets:House:HouseName CNY

20xx-xx-xx open Liabilities:Mortgage:House CNY
20xx-xx-xx open Liabilities:Mortgage:Interest CNY

1990-05-28 open Liabilities:Credit:CMB:xxxx CNY,USD
1990-05-28 open Liabilities:Huabei CNY

2018-10-30 open Income:CompanyName:Salary CNY
1990-05-28 open Income:PnL CNY
1990-05-28 note Income:PnL &amp;quot;盈亏&amp;quot;
1990-05-28 open Income:PnL:Fund CNY

2016-07-07 open Expenses:Gov:HousingFund CNY
2016-07-07 open Expenses:Gov:Pension CNY
2016-07-07 open Expenses:Gov:Unemployment CNY
2016-07-07 open Expenses:Gov:MedicalCare CNY
2016-07-07 open Expenses:Gov:IncomeTax CNY

1990-05-28 open Expenses:Daily:Cloth CNY
1990-05-28 open Expenses:Daily:Food CNY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要是几类：&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;Asset:Bank&lt;/dt&gt;
&lt;dd&gt;银行卡&lt;/dd&gt;
&lt;dt&gt;Liabilities:Credit&lt;/dt&gt;
&lt;dd&gt;信用卡&lt;/dd&gt;
&lt;dt&gt;Incoume:CompanyName:Salary&lt;/dt&gt;
&lt;dd&gt;工资&lt;/dd&gt;
&lt;dt&gt;Incoume:PnL&lt;/dt&gt;
&lt;dd&gt;用于盈亏，对应加了一条 note，方便记忆&lt;/dd&gt;
&lt;dt&gt;Expenses:Gov&lt;/dt&gt;
&lt;dd&gt;五险一金&lt;/dd&gt;
&lt;dt&gt;Expenses:XXX&lt;/dt&gt;
&lt;dd&gt;其它支出&lt;/dd&gt;
&lt;dt&gt;Equity:Opening-Balances&lt;/dt&gt;
&lt;dd&gt;开户平衡&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;有几点需要主要的是，工资的话，是算上应收，再算五险一金，最后是收入。还有房贷，房屋价值和利息是要分开算的。&lt;/p&gt;

&lt;h3 id=&#34;当前余额&#34;&gt;当前余额&lt;/h3&gt;

&lt;p&gt;现在有账户了，然后就是账户里的余额， &lt;code&gt;beancount&lt;/code&gt; 已经考虑到了，所以有 &lt;code&gt;pad&lt;/code&gt; ，而且上文开户有一个 &lt;code&gt;Equity:Opening-Balances&lt;/code&gt; ，就是用来初始化账户，而且在你补充了中间的条目之后， &lt;code&gt;pad&lt;/code&gt; 的值也会对应更新。&lt;/p&gt;

&lt;p&gt;用法是从 &lt;code&gt;时间1&lt;/code&gt; 到 &lt;code&gt;时间2&lt;/code&gt; 期间 &lt;code&gt;账户1&lt;/code&gt; 的余额是 &lt;code&gt;banlance&lt;/code&gt; 指明的值，差值算到 &lt;code&gt;账户2&lt;/code&gt; 内。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;  时间1 pad 账户1 账户2
  时间2 balance 账户1 金额1 货币
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们初始化账户可以把 &lt;code&gt;时间1&lt;/code&gt; 设置为生日， &lt;code&gt;时间2&lt;/code&gt; 设置为当前，这样表示之前帐目的都用 &lt;code&gt;Opening-Balances&lt;/code&gt; 先抹平，如果我们之前有记录的内容，直接补充进去就好了， &lt;code&gt;pad&lt;/code&gt; 会自己更新。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nil&#34;&gt;1990-05-28 pad Assets:Bank:CMB:6838:Deposit Equity:Opening-Balances
2019-08-10 balance Assets:Bank:CMB:6838:Deposit xxx CNY

1990-05-28 pad Liabilities:Credit:CMB Equity:Opening-Balances
2019-08-10 balance Liabilities:Credit:CMB -xxxxx CNY
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到此，我们的账户初始化就完成了。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;我们可以打开 fava 看一下我们的资产：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fava xx.bean
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在资产页，我们填的余额都已经更新了。&lt;/p&gt;

&lt;p&gt;其中还有一个点，就是 &lt;code&gt;Book Value&lt;/code&gt; 和 &lt;code&gt;Market Value&lt;/code&gt; 。复式记账多用于公司，所以这两个值主要也是公司财务比较熟悉的。&lt;/p&gt;

&lt;dl&gt;
&lt;dt&gt;Book Value&lt;/dt&gt;
&lt;dd&gt;纸面上的价值，就是欠的钱都还了之后的资产&lt;/dd&gt;
&lt;dt&gt;Market Value&lt;/dt&gt;
&lt;dd&gt;股票价值，Beancount 里就是制定 price 之后计算出来的价格&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;考虑到自动化需要一个比较好用的工具，等下一片文章再具体写一下工具的情况。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>dnsmasq &#43; Cloudflare DoH 自建 DNS</title>
      <link>https://page.codespaper.com/2019/dnsmasq-cloudflare-doh/</link>
      <pubDate>Sun, 30 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2019/dnsmasq-cloudflare-doh/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;有时候方案一些网站的时候，会由于 DNS 解析出问题，即使网络情况很好，也会出现无法访问的情况，
而最近很流行的 DNS over HTTPS 更是十分的稳定安全，所以，通过自建 DNS，可以精确的得到解析结果。&lt;/p&gt;

&lt;p&gt;文章中的所有文件可以直接在我的仓库中找到：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/zwpaper/dotfile/tree/master/archlinux&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Archlinux dot file&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;方案&#34;&gt;方案&lt;/h2&gt;

&lt;h3 id=&#34;dnsmasq&#34;&gt;dnsmasq&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dnsmasq&lt;/code&gt; 是一个十分老牌的软件了，可以提供 &lt;code&gt;DNS&lt;/code&gt; 缓存和 &lt;code&gt;DHCP&lt;/code&gt; 服务功能，还带了一个 &lt;code&gt;PXE&lt;/code&gt; 服务器，但是这些都不是我们需要关注的点，我们只看 &lt;code&gt;DNS&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;作为域名解析服务器 &lt;code&gt;DNS&lt;/code&gt; ， &lt;code&gt;dnsmasq&lt;/code&gt; 可以通过缓存 &lt;code&gt;DNS&lt;/code&gt; 请求来提高对访问过的网址的连接速度，所以有一些结果虽然第一次比较耗时，但是后续就可以直接用本地结果了。&lt;/p&gt;

&lt;p&gt;最重要的是 &lt;code&gt;dnsmasq&lt;/code&gt; 轻量而且容易配置，几乎默认的配置就足够我们使用了。&lt;/p&gt;

&lt;h3 id=&#34;dns-over-https&#34;&gt;DNS over HTTPS&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;DNS over HTTPS&lt;/code&gt; 也就是常见的 &lt;code&gt;DoH&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;没什么问题是加一层解决不了的，如果有，那个加两层。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;DNS&lt;/code&gt; 经常出问题，那就把 &lt;code&gt;UDP&lt;/code&gt; 换成 &lt;code&gt;TCP&lt;/code&gt; ，还解决不了？那就再上一层 &lt;code&gt;TLS&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;由于 &lt;code&gt;HTTP&lt;/code&gt; 协议需要多次数据交互，还有 &lt;code&gt;TLS&lt;/code&gt; 的加解密，所以在时间上，耗时比传统的 &lt;code&gt;DNS&lt;/code&gt; 高了不少。
上文也提到了 &lt;code&gt;dnsmasq&lt;/code&gt; 有缓存作用，所以也一定程度缓解了这个问题。&lt;/p&gt;

&lt;h4 id=&#34;cloudflare-1-dot-1-dot-1-dot-1&#34;&gt;Cloudflare 1.1.1.1&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Cloudflare&lt;/code&gt; 本来是一个主打 &lt;code&gt;CDN&lt;/code&gt; 和 &lt;code&gt;权威 DNS&lt;/code&gt; 的企业，在 2018 年的时候强势推出了 &lt;code&gt;1.1.1.1&lt;/code&gt; 的 &lt;code&gt;local DNS&lt;/code&gt; ， 还带着 &lt;code&gt;DNS over HTTPS&lt;/code&gt; 支持。
目前比较有名的 &lt;code&gt;DoH&lt;/code&gt; 服务就只有 &lt;code&gt;Cloudflare&lt;/code&gt; 和 &lt;code&gt;Google&lt;/code&gt; ，而这是 &lt;code&gt;Cloudflare&lt;/code&gt; 的主战场，自然也就是一个优选。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cloudflare DoH Client&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Cloudflare&lt;/code&gt; 还提供了一个 &lt;code&gt;Golang&lt;/code&gt; 开发的 &lt;code&gt;DoH&lt;/code&gt; &lt;a href=&#34;https://developers.cloudflare.com/1.1.1.1/dns-over-https/cloudflared-proxy/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;客户端&lt;/a&gt;，可以直接在本地把 &lt;code&gt;DoH&lt;/code&gt; 转为传统 &lt;code&gt;DNS&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;得益于 &lt;code&gt;Golang&lt;/code&gt; 开发，所以所有需要下载的内容就是一个二进制文件： &lt;code&gt;cloudflared&lt;/code&gt; 。当然如果对应 &lt;code&gt;Linux 发行版&lt;/code&gt; ，想安装 &lt;code&gt;deb&lt;/code&gt; 或者 &lt;code&gt;rpm&lt;/code&gt; ，官网也是有的。&lt;/p&gt;

&lt;p&gt;运行方式也只需要如下命令即可：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cloudflared proxy-dns --address 0.0.0.0 --port 5353
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dnsmasq-china-list&#34;&gt;dnsmasq china list&lt;/h3&gt;

&lt;p&gt;上文提到了， &lt;code&gt;DoH&lt;/code&gt; 相对比较耗时，而 &lt;code&gt;DNS&lt;/code&gt; 的问题更多地出现在国外的域名上，所以国内的域名，我们其实直接用传统方案就可以了，
&lt;a href=&#34;https://github.com/felixonmars/dnsmasq-china-list&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;dnsmasq china list&lt;/a&gt; 就是一个国内的域名列表，而最方便的地方在于可以直接生成 &lt;code&gt;dnsmasq&lt;/code&gt; 的配置文件。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;p&gt;考虑到这是一个服务，需要长期运行，所以我们使用 &lt;code&gt;systemd&lt;/code&gt; 来运行。&lt;/p&gt;

&lt;p&gt;配置文件如下，考虑到文章不一定能及时更新，可以看我的 &lt;a href=&#34;https://github.com/zwpaper/dotfile/tree/master/archlinux&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;dot file repo&lt;/a&gt;：&lt;/p&gt;

&lt;h3 id=&#34;cloudflare&#34;&gt;Cloudflare&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[Unit]
Description=cloudflare DoH
Documentation=cloudflare DNS over HTTPS

[Service]
Type=simple
ExecStart=/home/username/.bin/cloudflared proxy-dns --address 0.0.0.0 --port 5353
ExecStop=kill $MAINPID
Restart=always

[Install]
WantedBy=default.target
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dnsmasq-1&#34;&gt;dnsmasq&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dnsmasq&lt;/code&gt; 直接使用自已安装的时候带的 &lt;code&gt;systemd&lt;/code&gt; 配置文件就足够了，主要是改一下 &lt;code&gt;dnsmasq&lt;/code&gt; 的&lt;a href=&#34;https://github.com/zwpaper/dotfile/blob/master/archlinux/config/dnsmasq/dnsmasq.conf&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;配置文件&lt;/a&gt;， &lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt; ：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;no-hosts
no-resolv

server=127.0.0.1#5353
conf-dir=/etc/dnsmasq.d/

log-queries
log-facility=/var/log/dnsmasq/dnsmasq.log
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装 &lt;code&gt;dnsmasq-china-list&lt;/code&gt; ，简单地来说，运行一个&lt;a href=&#34;https://github.com/zwpaper/dotfile/blob/master/archlinux/config/dnsmasq/install.sh&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;脚本&lt;/a&gt;就可以：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://raw.githubusercontent.com/zwpaper/dotfile/master/archlinux/config/dnsmasq/install.sh
sudo bash install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;效果&#34;&gt;效果&lt;/h2&gt;

&lt;p&gt;到此，安装就完成了，目前的效果&lt;/p&gt;

&lt;h3 id=&#34;国内域名&#34;&gt;国内域名：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;# dig @127.0.0.1 163.com

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.14.3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @127.0.0.1 163.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 3825
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;163.com.                       IN      A

;; ANSWER SECTION:
163.com.                98      IN      A       123.58.180.7
163.com.                98      IN      A       123.58.180.8

;; Query time: 44 msec
;; SERVER: 127.0.0.1#53(127.0.0.1)
;; WHEN: Sun Jun 30 17:19:54 HKT 2019
;; MSG SIZE  rcvd: 68
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看日志：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Jun 30 17:19:54 dnsmasq[20723]: query[A] 163.com from 127.0.0.1
Jun 30 17:19:54 dnsmasq[20723]: forwarded 163.com to 180.76.76.76
Jun 30 17:19:54 dnsmasq[20723]: forwarded 163.com to 114.114.115.115
Jun 30 17:19:54 dnsmasq[20723]: forwarded 163.com to 114.114.114.114
Jun 30 17:19:54 dnsmasq[20723]: reply 163.com is 123.58.180.7
Jun 30 17:19:54 dnsmasq[20723]: reply 163.com is 123.58.180.8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到 &lt;code&gt;dnsmasq&lt;/code&gt; 转发了三个请求到国内的 &lt;code&gt;local dns&lt;/code&gt; 了。&lt;/p&gt;

&lt;h3 id=&#34;国外的请求&#34;&gt;国外的请求&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;# dig @127.0.0.1 google.com

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.14.3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @127.0.0.1 google.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 36565
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1452
; PAD (69 bytes)
;; QUESTION SECTION:
;google.com.                    IN      A

;; ANSWER SECTION:
google.com.             272     IN      A       216.58.217.206

;; Query time: 251 msec
;; SERVER: 127.0.0.1#53(127.0.0.1)
;; WHEN: Sun Jun 30 17:30:37 HKT 2019
;; MSG SIZE  rcvd: 138
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看日志，转发到 &lt;code&gt;127.0.0.1&lt;/code&gt; 了，因为我们的 &lt;code&gt;cloudflared&lt;/code&gt; 是运行在本地的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Jun 30 17:30:36 dnsmasq[20723]: query[A] google.com from 127.0.0.1
Jun 30 17:30:36 dnsmasq[20723]: forwarded google.com to 127.0.0.1
Jun 30 17:30:37 dnsmasq[20723]: reply google.com is 216.58.217.206
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cache&#34;&gt;Cache&lt;/h3&gt;

&lt;p&gt;再发起一次请求，看日志，直接从 cache 返回了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Jun 30 17:31:31 dnsmasq[20723]: query[A] google.com from 127.0.0.1
Jun 30 17:31:31 dnsmasq[20723]: cached google.com is 216.58.217.206
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>从 Slurm &#43; Lustre 到 Kubeflow &#43; Ceph (0)，简介和容器中使用显卡</title>
      <link>https://page.codespaper.com/2019/slurm-lustre-to-kubeflow-ceph/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2019/slurm-lustre-to-kubeflow-ceph/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;传统的高性能计算集群一般都习惯性地使用 &lt;code&gt;Slurm&lt;/code&gt; + &lt;code&gt;Lustre&lt;/code&gt; 的方案作为任务调度和存储，然而，随着容器的发展，互联网业务的部署已经越来越多地开始了容器化，而 &lt;code&gt;Kubernetes&lt;/code&gt; 也成为了容器编排的事实标准。&lt;/p&gt;

&lt;p&gt;而且，对比容器化的简洁， &lt;code&gt;Slurm&lt;/code&gt; 和 &lt;code&gt;Lustre&lt;/code&gt; 复杂的配置，让人头疼的运維压力，也让作为互联网的最前沿之一的机器学习，也开始了容器化探索。&lt;/p&gt;

&lt;p&gt;本系列文章主要记录了在 &lt;code&gt;Kubernetes&lt;/code&gt; 内使用 &lt;code&gt;Pytorch&lt;/code&gt; 运行 &lt;code&gt;ImageNet&lt;/code&gt; 的淌坑经验，同时也使用 CephFS 作为网络存储，解决数据存放问题。&lt;/p&gt;

&lt;p&gt;计划：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简介和容器内使用显卡（本文）&lt;/li&gt;
&lt;li&gt;Kuberentes 和 Device Plugin&lt;/li&gt;
&lt;li&gt;Kubeflow 和 Pytorch-Operator&lt;/li&gt;
&lt;li&gt;CSI(Cofntainer Storage Interface) 和 CephFS 网络存储&lt;/li&gt;
&lt;li&gt;mnist Demo 和分布式训练（MPI)&lt;/li&gt;
&lt;li&gt;分布式 ImageNet&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;slurm&#34;&gt;Slurm&lt;/h3&gt;

&lt;p&gt;Slurm(Simple Linux Utility for Resource Management)
是一个用于Linux 和 Unix 内核系统的免费、开源的任务调度工具，被世界范围内的（包括天河等）超级计算机和计算机群广泛采用。&lt;/p&gt;

&lt;p&gt;Slurm 的成熟度毋庸置疑，但是有两个问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在互联网公司不一定能有专人维护 Slurm 集群&lt;/li&gt;
&lt;li&gt;交付环境没有 Slurm&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;lustre&#34;&gt;Lustre&lt;/h3&gt;

&lt;p&gt;Lustre(得名于：Linux + Cluster)
一种平行分布式文件系统，通常用于大型计算机集群和超级计算机。很多时候都是和 Slurm 配套使用的，所以也会有类似 Slurm 的两个问题。&lt;/p&gt;

&lt;h3 id=&#34;kubernetes-plus-ceph&#34;&gt;Kubernetes + Ceph&lt;/h3&gt;

&lt;p&gt;互联网时代，容器化并使用 Kubernetes 同时使用 Ceph 作为网络存储肯定是毫无疑问的方案和方向。如果 Kubernetes + Ceph 能够解决机器学习中高性能集群资源分配和利用的问题，那对于互联网公司，肯定会是更好的选择。&lt;/p&gt;

&lt;h2 id=&#34;容器内使用显卡&#34;&gt;容器内使用显卡&lt;/h2&gt;

&lt;h3 id=&#34;gpu&#34;&gt;GPU&lt;/h3&gt;

&lt;p&gt;现在机器学习的主流是深度学习，自然 GPU 是少不了的。本文中使用了 Nvidia 的 GTX 1080Ti。&lt;/p&gt;

&lt;h4 id=&#34;驱动&#34;&gt;驱动&lt;/h4&gt;

&lt;p&gt;首先确认机器上是否有 GPU 卡：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lspci -vnn | grep NVIDIA

# Nvidia 显卡可以用自家工具看到详情
nvidia-smi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;确认安装了 Nvidia 驱动 (cuda-driver)，一般直接从源里安装即可。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/NVIDIA/nvidia-docker/wiki/Frequently-Asked-Questions#how-do-i-install-the-nvidia-driver&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/NVIDIA/nvidia-docker/wiki/Frequently-Asked-Questions#how-do-i-install-the-nvidia-driver&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果官方源里没有，那就在 Nvidia 提供的&lt;a href=&#34;https://www.nvidia.com/object/unix.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;下载安装文件，安装也可。&lt;/p&gt;

&lt;p&gt;这里需要注意的是高版本的 CUDA 同样需要高版本的驱动，对应关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://page.codespaper.com/images/cudadriver.jpg&#34; alt=&#34;CUDA Driver&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;nvidia-docker-2-dot-0&#34;&gt;Nvidia docker 2.0&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/NVIDIA/nvidia-docker&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/NVIDIA/nvidia-docker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;默认的 Docker 是不支持 GPU 的，所以我们需要 &lt;code&gt;nvidia-docker&lt;/code&gt; ，这是 Nvidia 为了支持 Docker 生态出的一个包，而 &lt;code&gt;nvidia docker 2.0&lt;/code&gt; 是第二版，主要是为 &lt;code&gt;Docker&lt;/code&gt; 新增了一个 &lt;code&gt;nvidia&lt;/code&gt; 的运行时，&lt;/p&gt;

&lt;p&gt;所以在安装完 &lt;code&gt;nvidia docker 2.0&lt;/code&gt; 后，需要把 Docker 的默认运行时个性为 &lt;code&gt;nvidia&lt;/code&gt; 。可以通过修改 docker 配置文件 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 让 docker 能够使用 &lt;code&gt;Nvidia Container Runtime&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Nvidia Container Runtime&lt;/code&gt; 作为核心部分，在原有的容器运行时 &lt;code&gt;runc&lt;/code&gt; 的基础上增加一个 &lt;code&gt;prestart hook&lt;/code&gt; ，用于调用 &lt;code&gt;libnvidia-container&lt;/code&gt; 库。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;libnvidia-container&lt;/code&gt; 提供一个库和一个简单的 Cli 工具，这个库让容器能够使用 Nvidia 的 GPU。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;runc&lt;/code&gt; 是docker默认的容器运行时，根据 &lt;code&gt;Open Containers Initiative (OCI)&lt;/code&gt; 创建容器。&lt;/p&gt;

&lt;p&gt;总而言之，就是当我们要在 Docker 里使用 Nvidia GPU 时，就必须要安装 &lt;code&gt;Nvidia Docker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装完之后，基本的用法如下，可以测试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --runtime=nvidia --rm nvidia/cuda nvidia-smi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果出现 &lt;code&gt;brand = tesla: unknown&lt;/code&gt; 的错误，就是 cuda 的版本和我们使用的驱动不匹配，可以看一下宿主显卡驱动的版本和使用的 CUDA 版本，然后对照上文的图片看是否匹配。&lt;/p&gt;

&lt;p&gt;可以使用对应版本的 CUDA 镜像，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run --runtime=nvidia --rm nvidia/cuda:8.0-runtime nvidia-smi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以更新宿主机驱动。&lt;/p&gt;

&lt;p&gt;至此，我们就可以在容器内使用 GPU 了，但是我们想在 Kubernetes 内使用，还需要使用 &lt;code&gt;Device Plugin&lt;/code&gt; ，这个会在后文说到。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>作为新手，为什么我选 Typescript</title>
      <link>https://page.codespaper.com/2019/js-to-ts-for-newbie/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2019/js-to-ts-for-newbie/</guid>
      <description>

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;最近尝试着使用 Taro 写一个微信小程序，&lt;a href=&#34;https://taro.jd.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Taro&lt;/a&gt; 是&lt;a href=&#34;https://aotu.io/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;京东凹凸实验室&lt;/a&gt;开发的一款使用 &lt;a href=&#34;https://reactjs.org/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;React&lt;/a&gt; 语法多端统一开发解决方案，
其实也就是使用 React 语法编写一次，使用不同的编译方式编译出 BATT 各家小程序，React Native 程序。&lt;/p&gt;

&lt;p&gt;Taro 在对各端支持上还有一些差异，在开发的时候有一些细节需要关注。
而目前小程序基本只有微信小程序比较热门，而且腾讯推出云开发，可以一定程度省去后端的工作量，
所以目前入门基本只关注微信小程序就足够了。&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;作为一名后端工程师，对前端（Web 端，App 端）经验还是比较缺失的，
JavaScript 也是第一次真正认真地接触。&lt;/p&gt;

&lt;p&gt;由于使用 React 的语法，所以说到的 JavaScript 基本都含 &lt;a href=&#34;https://reactjs.org/docs/introducing-jsx.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;JSX&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;javascript-从入门到放弃&#34;&gt;JavaScript 从入门到放弃&lt;/h2&gt;

&lt;p&gt;由于 JavaScript 的资源相对多，所以入门的时候没有太多犹豫就选择了 JavaScript，而不是大热的 TypeScript，
也正是由于这个选择，才会让我感觉到为什么现在 TypeScript 会大热。&lt;/p&gt;

&lt;p&gt;JavaScript 最大的特点应该就是自由，动态语言的弱类型系统，类型之间可以随意转换，而且转换发生在运行时，
写代码的时候看起来都没有问题，可是运行起来之后，可能就会出现各种各样的报错。&lt;/p&gt;

&lt;p&gt;在网络调用时，由于对类型没有预先的考虑，基本就是把同一个函数复制到另一个位置，
修改一下使用的参数，就又堆叠了几行代码。&lt;/p&gt;

&lt;h2 id=&#34;typescript&#34;&gt;TypeScript&lt;/h2&gt;

&lt;p&gt;TypeScript 和 JavaScript 几乎可能无缝转化，我把一个 JavaScript 的文件后缀改成 TypeScript 之后，
把一些变量的类型补上，就可以编译通过了。
但是也就是这个补充类型的过程中，开始思考这些类似的地方，我应该把他们抽象出来。&lt;/p&gt;

&lt;h3 id=&#34;类型系统&#34;&gt;类型系统&lt;/h3&gt;

&lt;p&gt;强类型系统可以在编译时做出足够多的检查，减少运行时的错误，运行时错误只能依赖于对 App 的各种各样的测试，
而我们都知道，测试也是很难做到面面俱到的，所以让错误出现在编译期，显然是更好的选择。&lt;/p&gt;

&lt;h4 id=&#34;interface&#34;&gt;Interface&lt;/h4&gt;

&lt;p&gt;TypeScript 的特点就是在 JavaScript 中加入了类型检查，而最核心的特性之一就是 &lt;code&gt;Interface&lt;/code&gt; 所实现的 &lt;code&gt;鸭子类型&lt;/code&gt; 。
&lt;code&gt;interface&lt;/code&gt; 也是在 JavaScript 中没有的， &lt;code&gt;interface&lt;/code&gt; 指定了成员们的类型，主要用途也正是做更多的类型检查。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;interface&lt;/code&gt; 规定的是一系列约束，而不需要实例显示去实现，当实例满足 &lt;code&gt;interface&lt;/code&gt; 中的约束时，
那实例就可以用到这个 &lt;code&gt;interface&lt;/code&gt; 。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;当他走路像鸭子，叫起来像鸭子，游泳也像鸭子，那他就可以称为鸭子&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于在 JavaScript 中，函数是一等公民，和其它类型无异，所以在 &lt;code&gt;interface&lt;/code&gt; 中，
我们可以列出来需要的变量和其类型，同样的，我们也可以列出来需要实现的函数。&lt;/p&gt;

&lt;p&gt;最后，在 TypeScript 编译成 JavaScript 之后， &lt;code&gt;interface&lt;/code&gt; 的信息是会被删除掉的，
也就是 &lt;code&gt;interface&lt;/code&gt; 的检查只发生在 TypeScript 中。&lt;/p&gt;

&lt;h4 id=&#34;class&#34;&gt;Class&lt;/h4&gt;

&lt;p&gt;ECMAScript 6(ES6) 正式给 JavaScript 世界引入了 &lt;code&gt;Class&lt;/code&gt; 。TypeScript 在这个基础上又衍生出了自己的特性。&lt;/p&gt;

&lt;p&gt;首当其冲就是 static 属性，可以让你在没有实例时，直接使用类函数，最常见的用法就是用于新建一个类的实例。
这样就可以把新建实例的函数也归到类的定义中。&lt;/p&gt;

&lt;p&gt;通常，我们不需要把 &lt;code&gt;Class&lt;/code&gt; export 出去，只 export 对应的 “构造函数” 就可以了，交互可以通过 &lt;code&gt;interface&lt;/code&gt; 完成。&lt;/p&gt;

&lt;h2 id=&#34;后话&#34;&gt;后话&lt;/h2&gt;

&lt;p&gt;当然，我 JavaScript 只是使用了比较短暂的时间，很多地方没有深入理解，没有领会到正确的用法，
但也正是这样，我反而觉得 JavaScript 自由性让人在上手的时候，只关注于能实现就行，
而不关注软件工程中的程序设计。&lt;/p&gt;

&lt;p&gt;反观 TypeScript，强制的类型检查，让人不自觉地考虑，这个地方是否应该有一个类？
学习的时候，很快就会看到 Interface，Class，都是熟悉的味道，很自然地就会想，
我这里是否能抽象，后面这里是否可以复用。&lt;/p&gt;

&lt;p&gt;JavaScript 是一个很伟大的语言，在前端有着无与伦比的统治力，
有着面向对象的特性，有函数式编程的特性，熟练之后可以写出各种花式的代码，
但是我还是更喜欢死板一点的 TypeScript，简单上手就可以写出不错的代码，后续也可以在这个基础上不断迭代。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>为什么我觉得 Golang 更好</title>
      <link>https://page.codespaper.com/2019/why-golang/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2019/why-golang/</guid>
      <description>

&lt;h2 id=&#34;less-is-exponentially-more-读后感&#34;&gt;Less is exponentially more 读后感&lt;/h2&gt;

&lt;p&gt;最近看到 Rob Pike 在 2012 年写的一篇文章，&lt;a href=&#34;https://commandcenter.blogspot.com/2012/06/less-is-exponentially-more.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Less is exponentially more&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果你不知道 Rob Pike 是谁：&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%BE%85%E5%8B%83%C2%B7%E6%B4%BE%E5%85%8B&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Rob Pike&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或者用一句话介绍，Golang 作者之一&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;结合之前看到对于 Golang 编程思想的讨论，对这篇文章真是相见恨晚&lt;/p&gt;

&lt;h2 id=&#34;从-c-plus-plus-到-golang&#34;&gt;从 C++ 到 Golang&lt;/h2&gt;

&lt;p&gt;Golang 的前身是 Rob Pike 在 1980+ 年在贝尔实验室写的一门编程语言：&lt;a href=&#34;https://swtch.com/~rsc/thread/newsqueak.pdf&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Newsqueak&lt;/a&gt;，
在 2007 年的时候，C++标准委员会正在紧锣密鼓地准备 C++0x (现在的 C++11)，
作为一名在 Google 的 C++ 工程师 Rob Pike 自然也十分关注，可是也在这时候，
Rob 觉得不应该把这么多的特性都放到一门语言里，同时也觉得在 Newsqueak 里有一些特性，
如果能用在开发里，会对服务器端的很多开发都会有帮助。&lt;/p&gt;

&lt;p&gt;可是 C++ 庞大复杂的体系，要加一些比较不一样的特性已经不是一件易事，而且可能也不值得，
所以在 C++ 项目编译的时间里（编译一次要 45 分钟，还是在编译集群上！）Rob 就拉上了
&lt;a href=&#34;https://en.wikipedia.org/wiki/Ken%5FThompson&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Ken Thompson&lt;/a&gt; 和 Robert Griesemer 决定要做点事情，Golang 从此开始登上历史的舞台。&lt;/p&gt;

&lt;p&gt;要知道 Ken, Rob, 都是贝尔实验室的大佬，一直在 Google 做 C++, 决心要针对 C++ 做一个优化，
这就是突破性的了，更别说 Ken 是 Unix，Plan 9，C 语言作为作者之一。&lt;/p&gt;

&lt;h2 id=&#34;大道至简&#34;&gt;大道至简&lt;/h2&gt;

&lt;p&gt;在文章中，就如文章标题，Rob 希望重新造轮子的原因主要就是觉得 C++ 太复杂了，觉得大道应该至简，
所以才考虑重新从头设计一门语言。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章里多次提到了在 C++ 编译的时候，Rob 去找同事们聊天，这个编译时间，
对 Rob 来说，应该还是感觉挺难受的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本来 Robert 希望 Go 从 C 语言出发，但是最后还是决定，从零出发，至简就该如此。所以网上常说 Golang
是 Better C，其实 Golang 是 Better language。&lt;/p&gt;

&lt;p&gt;文章中提到了很多的简化，只要写代码过程中，可能需要考虑，而又没必要的东西，Golang 都直接不出现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;没有头文件&lt;/li&gt;
&lt;li&gt;常量只能是数字&lt;/li&gt;
&lt;li&gt;没有子类型继承&lt;/li&gt;
&lt;li&gt;文件被编译到一个包里&lt;/li&gt;
&lt;li&gt;没有指针运算&lt;/li&gt;
&lt;li&gt;内存一直以零值初始化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等。&lt;/p&gt;

&lt;p&gt;甚至，连泛型都没有，而且 Golang 也借鉴了函数式编程的函数作为 &lt;code&gt;first class object&lt;/code&gt; ，
但是其它一些函数式编程的优点就什么也都没有了，就像： &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt; 等，&lt;/p&gt;

&lt;p&gt;因为 Rob 说，用 &lt;code&gt;for&lt;/code&gt; 吧&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/robpike/filter&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/robpike/filter&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从语言层面，Golang 就对代码规范进行了限制，还提供了 fmt 格式化工具，doc 文档体系，
这都像是在说，这些不关紧要的东西，就都不要去考虑了。&lt;/p&gt;

&lt;p&gt;并发，也是一样的，从语言级别的支持，一个 &lt;code&gt;go&lt;/code&gt; 关键字，加上 &lt;code&gt;channel&lt;/code&gt; 的 CSP 并发模型，
可以说是很大程度地简化了开发高并发软件的复杂度。&lt;/p&gt;

&lt;h2 id=&#34;真正的-oop&#34;&gt;真正的 OOP&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;If C++ and Java are about type hierarchies and the taxonomy of types, Go is about composition.&lt;/p&gt;

&lt;p&gt;Go takes that idea and pushes it very far. It is a language of composition and coupling.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之前看到一个讨论，就在说 Golang 的编程思想，提到为什么 Golang 不用传统的 OOP 思想，
而是用了一套 &lt;code&gt;组合&lt;/code&gt; 代替，原因也在这，Rob 认为 Java 和 C++ 推崇的 OOP 思想更多的是历史包袱，
程序员们更应该关注的是接口。&lt;/p&gt;

&lt;p&gt;目前的 OOP 思想更多的都是 Java 和 C++ 的流行而发展出来的，与最初的 &lt;code&gt;对象范式&lt;/code&gt; 已经走上不同的道路了。
Golang 也许是第一个明确使用了最初 &lt;code&gt;对象范式&lt;/code&gt; 设计的语言，这个可能还需要用一篇文章来研究。&lt;/p&gt;

&lt;h2 id=&#34;高层抽象&#34;&gt;高层抽象&lt;/h2&gt;

&lt;p&gt;最近也在看一些函数式编程的文章，有一个观点我还是挺认可的：&lt;/p&gt;

&lt;p&gt;函数式编程把一些无关紧要的问题封装在了语言级别，写程序时，可以不需要考虑，如 &lt;code&gt;内存管理&lt;/code&gt; ， &lt;code&gt;for 循环&lt;/code&gt; 等。
以前函数式编程不流行，更多的是因为当时的算力或者编译程序不足以让函数式语言的体验与过程式语言匹敌，
但是现在时机已经来了，函数式编程马上要再次走上舞台了。&lt;/p&gt;

&lt;p&gt;一个例子是 &lt;code&gt;内存管理&lt;/code&gt; ，虽然说这是很多高级语言都有的特性，可是这不也是一个证明，语言级别能解决好的事情，
就让语言去解决吧。&lt;/p&gt;

&lt;p&gt;另一个例子是 Clojure 一次对 Map 和 vector 扩展，内部进行了并行优化，开发者不需要改变就得到了性能提升。&lt;/p&gt;

&lt;p&gt;Golang 对并发的封装，也是一个高层抽象的表现。&lt;/p&gt;

&lt;p&gt;这个也可能需要一篇文章来研究。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用 GPG 在 Emacs 中加密 Org Mode 笔记文件</title>
      <link>https://page.codespaper.com/2019/gpg-encrypt-org/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2019/gpg-encrypt-org/</guid>
      <description>

&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;

&lt;p&gt;Org Mode 作为主要 GTD 和笔记软件，需要使用网盘来同步信息，虽然 Dropbox 名声十分良好，
但是有一些敏感信息，还是认为谁都不值得信任。&lt;/p&gt;

&lt;p&gt;所以需要使用 GPG 加密后再传到 Dropbox，而 Emacs 中， &lt;code&gt;EasyPG Assistant&lt;/code&gt; 可以很方便地加解密。&lt;/p&gt;

&lt;h2 id=&#34;gpg&#34;&gt;GPG&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/GnuPG&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://zh.wikipedia.org/wiki/GnuPG&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GNU Privacy Guard（GnuPG或GPG）是一种加密软件，它是PGP加密软件的满足GPL的替代物。GnuPG依照由IETF订定的OpenPGP技术标准设计。
GnuPG用于加密、数字签名及产生非对称钥匙对的软件。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果不了解 GPG，推荐看一下阮一峰老师的文章，快速入门
&lt;a href=&#34;http://www.ruanyifeng.com/blog/2013/07/gpg.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.ruanyifeng.com/blog/2013/07/gpg.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单地说就是可以通过 GPG 使用两种方式加密文件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对称加密，只使用密码对文件进行加密&lt;/li&gt;
&lt;li&gt;非对称加密，使用 GPG 密钥对文件进行加密，只有使用私钥能进行解密，而且需要私钥密码才能使用私钥&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;

&lt;h3 id=&#34;macos&#34;&gt;macOS&lt;/h3&gt;

&lt;p&gt;通过 brew 安装 gpg&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install gpg
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;emacs&#34;&gt;Emacs&lt;/h3&gt;

&lt;p&gt;通过 &lt;code&gt;use-package&lt;/code&gt; 配置 Emacs&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果没用过 &lt;code&gt;use-package&lt;/code&gt; 可以看一下：
&lt;a href=&#34;https://github.com/jwiegley/use-package&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/jwiegley/use-package&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;macOS 上的图形界面 Emacs 弹出密码窗口有问题，可以通过以下配置解决&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(setq epa-pinentry-mode &#39;loopback)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后，配置文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(use-package epa-file
  :ensure nil
  :config
  (epa-file-enable)
  (setq epa-pinentry-mode &#39;loopback))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;h3 id=&#34;对称加密&#34;&gt;对称加密&lt;/h3&gt;

&lt;p&gt;默认情况下，Emacs会使用对称加密的方法进行文件加密，实际就是用一个密码，使用 AES 对文件进行加密&lt;/p&gt;

&lt;p&gt;每次打开文件时，都要输入密码，保存时，甚至要输入两次，因为被当成新加密了。&lt;/p&gt;

&lt;p&gt;可以把密码缓存起来：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(setq epa-file-cache-passphrase-for-symmetric-encryption t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再打开和保存这个文件时，就不用输入密码，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是!!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个缓存是在 &lt;code&gt;gpg agent&lt;/code&gt; 进程里的，如果能确保电脑没别人会用，倒还好，
否则别人也是可能通过 &lt;code&gt;gpg agent&lt;/code&gt; 的缓存读到解密内容的！
或者说使用完，关了 Emacs 之后，其它人再重新打开，尝试读取，也是能载入缓存的！&lt;/p&gt;

&lt;p&gt;可以通过加一个 Hook，在关 Emacs 的时候，把 &lt;code&gt;gpg agent&lt;/code&gt; 也杀了，相对能安全点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-emacs-lisp&#34;&gt;(add-hook &#39;kill-emacs-hook (defun personal--kill-gpg-agent ()
                             (shell-command &amp;quot;pkill gpg-agent&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里我们用 defun 而不是 lambda，有兴趣可以看一下这篇文章：
&lt;a href=&#34;http://ergoemacs.org/emacs/emacs%5Favoid%5Flambda%5Fin%5Fhook.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://ergoemacs.org/emacs/emacs%5Favoid%5Flambda%5Fin%5Fhook.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;非对称加密&#34;&gt;非对称加密&lt;/h3&gt;

&lt;p&gt;使用 gpg key 对文件进行加密，这个目前应该是无懈可击的加密方式了&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;Org Mode&lt;/code&gt; 里使用非对称加密需要在文件开头加上：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-org&#34;&gt;# -*- mode:org; epa-file-encrypt-to: (&amp;quot;address@email.com&amp;quot;) -*-
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在保存的时候，Emacs 会提示让选择一个 GPG Key 进行加密，
加密以后，再打开这个文件，需要提供 GPG Key 私钥密码进行解密，然后再保存就不需要输入密码了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;我在用的时候有个问题，就是第一次新建文件加密保存后，每次都需要选择 Key 进行加密，
把 Buffer Kill 了之后，再打开文件使用就没有问题了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;gpg-相关&#34;&gt;GPG 相关&lt;/h3&gt;

&lt;h4 id=&#34;导出-key&#34;&gt;导出 Key&lt;/h4&gt;

&lt;p&gt;用了 GPG 加密，那私钥就非常的重要了，所以最好把私钥导出一份：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 找到自己的 Key ID，一长串字符
gpg --list-keys
# 导出，armor 表示使用可打印字符
gpg --export-secret-keys --armor AAAABBBBBBBBBCCCCCCC0000000000 &amp;gt;&amp;gt; /tmp/private.key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最重要的就是把导出文件保存好了，推荐离线保存！&lt;/p&gt;

&lt;p&gt;这个文件比较大，内容比较多。
可以把文件分割成几个小份，然后导出生成二维码，打印到纸上，离线保存。&lt;/p&gt;

&lt;h4 id=&#34;导入-key&#34;&gt;导入 Key&lt;/h4&gt;

&lt;p&gt;有导出，自然也有导入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gpg --import private.key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入之后 Key 没被信任，需要修改一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;gpg --edit-key AAAABBBBBBBBBCCCCCCC0000000000
# 看到提示符后输入 trust
# 再选择信任等级，我自己的 Key，我选 5
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Sessions control for hammerspoon</title>
      <link>https://page.codespaper.com/2015/sessions-control-hammerspoon-doc/</link>
      <pubDate>Sat, 11 Jul 2015 23:48:27 +0800</pubDate>
      
      <guid>https://page.codespaper.com/2015/sessions-control-hammerspoon-doc/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Sessions control 是一套基于 hammerspoon(Mac) 的脚本程序。可以通过快捷键把 Mac 中的各个窗口归类，并快速的在各个分类中切换，包括全屏的窗口也会自己切换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意：本程序还处于开发状态，不会关闭或丢失窗口，但并不对稳定性提供保证，请勿用于正式工作中！&lt;/p&gt;

&lt;h1 id=&#34;hammerspoon&#34;&gt;Hammerspoon&lt;/h1&gt;

&lt;h1 id=&#34;sessions-control&#34;&gt;sessions control&lt;/h1&gt;

&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;

&lt;p&gt;Sessions control 主要有以下三个功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;显示当前场景(sessions)&lt;/li&gt;
&lt;li&gt;为当前场景增删窗口(windows)&lt;/li&gt;
&lt;li&gt;在不同场景中切换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前实现主要通过把窗口最小化完成场景切换，后期版本会考虑把窗口隐藏，不占用任务栏空间。&lt;/p&gt;

&lt;p&gt;目前主要优势在于同时可以处理&lt;strong&gt;全屏窗口&lt;/strong&gt;，当切换场景时，全屏的窗口也会同时最小化，前台场景也会恢复应有的全屏状态。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;由于切换动画为系统动画，所以无法简单地关闭动画，在切换场景的时候会有部分动画。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各个场景都会定时保存到磁盘中，以保证各个场景不会因为 hammerspoon 或电脑的开关而丢失。&lt;/p&gt;

&lt;p&gt;对各个功能的快捷键提供定制，在脚本中可以很简单地修改快捷键。&lt;/p&gt;

&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;从 GitHub 中下载压缩包，或 clone 仓库到本地&lt;/li&gt;
&lt;li&gt;把 &lt;code&gt;sessions-control-hammerspoon&lt;/code&gt; 文件夹复制到 &lt;code&gt;~/.hammerspoon/&lt;/code&gt; 文件夹下&lt;/li&gt;
&lt;li&gt;更新 &lt;code&gt;~/.hammerspoon/&lt;/code&gt; 目录下 &lt;code&gt;init.lua&lt;/code&gt;，加入 sessions control 功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下载地址：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GitHub 地址：()[]&lt;/li&gt;
&lt;li&gt;GiuHub 压缩包地址：()[]&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注：&lt;code&gt;.hammerspoon&lt;/code&gt; 是隐藏文件夹，如果找不到相应位置，可以运行下载的程序中的 &lt;code&gt;setup&lt;/code&gt; 程序，会自动复制相应文件到目标位置，并自动更新 &lt;code&gt;init.lua&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注：&lt;code&gt;init.lua&lt;/code&gt; 是 &lt;code&gt;hammerspoon&lt;/code&gt; 本身自带的初始化文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;功能说明&#34;&gt;功能说明&lt;/h2&gt;

&lt;p&gt;在本说明中使用默认的快捷键进行说明，操作主要是先按住功能键，然后点击相应快捷键，默认键位如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;功能键：
ctrl + alt + cmd&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;显示当前场景：P&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;前一场景：[&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下一场景：]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;加入当前场景：L&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从当前场景删除：；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字键快速切换：1 ~ 场景数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code&gt;数字键快速切换&lt;/code&gt; 会按照场景数自动生成，通过按住功能键，加上相应的数字可以快速在场景间切换。&lt;/p&gt;

&lt;p&gt;默认键位都位于键盘右侧，通过功能分区。&lt;/p&gt;

&lt;h3 id=&#34;显示当前场景&#34;&gt;显示当前场景&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;P&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过系统通知展示当前各个场景，并自动编号，便于后面的快速切换。&lt;/p&gt;

&lt;p&gt;当然，同时进行太多任务会很乱，所以不应该同时有太多场景，同时，系统通知中不可以放入过长的内容，所以刚刚好 (;¬_¬)&lt;/p&gt;

&lt;h3 id=&#34;前后场景&#34;&gt;前后场景&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;前一场景：按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;[&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下一场景：按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;这两个功能主要用于切换上一个或下一个场景，完成按键后，会自动记录当前窗口的全屏状态，并把当前场景的窗口最小后，然后切换到新场景，恢复新场景中的窗口状态。&lt;/p&gt;

&lt;h3 id=&#34;窗口操作&#34;&gt;窗口操作&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;加入：按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;L&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除：按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;这两个功能主要用于对当前窗口的操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;把正在使用的窗口加入到当前场景中&lt;/li&gt;
&lt;li&gt;从当前场景中删除正在使用的窗口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;增删窗口之后会弹出通知提示完成操作，并显示当前场景中共有几个窗口&lt;/p&gt;

&lt;h3 id=&#34;快速切换&#34;&gt;快速切换&lt;/h3&gt;

&lt;p&gt;在查看场景时，每个场景名之前会有一个序号，该序号可用于快速切换，主要用于跨越多个场景的切换时，避免多个最大化，最小化动画。&lt;/p&gt;

&lt;p&gt;使用方法就是按住功能键后，再按相应的序号键（注：未测试小键盘区）&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;按住 &lt;code&gt;ctrl + alt + cmd&lt;/code&gt; 后，点击 &lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;程序实现&#34;&gt;程序实现&lt;/h1&gt;

&lt;p&gt;Sessions control 是基于 Hammerspoon 的脚本程序，使用 lua 编写，主要是两个文件实现。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sessions_control.lua&lt;/li&gt;
&lt;li&gt;sessions_head.lua&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了方便管理，把这两个文件放到了 &lt;code&gt;sessions-control-hammerspoon&lt;/code&gt; 文件夹中。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>